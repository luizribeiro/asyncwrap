# asyncwrap - Auto-generate Async Wrappers for Blocking Code

## Overview

This is a specification for building a Rust proc-macro crate called `asyncwrap`. The crate automatically generates async wrapper methods that delegate to blocking implementations via `tokio::task::spawn_blocking`.

## The Problem We're Solving

When building Rust libraries that wrap FFI or blocking I/O, a common pattern is:

1. Write a **blocking API** with the actual implementation
2. Write an **async API** that wraps each blocking method with `spawn_blocking`

This leads to massive boilerplate duplication:

```rust
// Blocking (the real implementation)
impl BlockingClient {
    pub fn get_data(&self) -> Result<Data> {
        // actual implementation
    }

    pub fn send_command(&self, cmd: Command) -> Result<()> {
        // actual implementation
    }

    // ... 20 more methods
}

// Async (tedious boilerplate)
impl AsyncClient {
    pub async fn get_data(&self) -> Result<Data> {
        let inner = Arc::clone(&self.inner);
        tokio::task::spawn_blocking(move || inner.get_data())
            .await
            .map_err(|e| Error::from(e))?
    }

    pub async fn send_command(&self, cmd: Command) -> Result<()> {
        let inner = Arc::clone(&self.inner);
        tokio::task::spawn_blocking(move || inner.send_command(cmd))
            .await
            .map_err(|e| Error::from(e))?
    }

    // ... 20 more identical wrappers
}
```

## The Solution

With `asyncwrap`, you write:

```rust
use asyncwrap::async_wrap;

// Mark methods for async generation
impl BlockingClient {
    #[async_wrap]
    pub fn get_data(&self) -> Result<Data> {
        // actual implementation
    }

    #[async_wrap]
    pub fn send_command(&self, cmd: Command) -> Result<()> {
        // actual implementation
    }

    // Private methods without #[async_wrap] are not wrapped
    fn internal_helper(&self) { }
}

// Generate async wrappers automatically
#[asyncwrap::wrapped(BlockingClient)]
pub struct AsyncClient {
    inner: Arc<BlockingClient>,
}

// That's it! AsyncClient now has:
// - pub async fn get_data(&self) -> Result<Data>
// - pub async fn send_command(&self, cmd: Command) -> Result<()>
```

## Detailed Design

### Attribute: `#[async_wrap]`

This attribute marks a method for async wrapper generation. It should:

1. Only be valid on `pub` methods (warn/error on private methods)
2. Only be valid on methods taking `&self` (not `&mut self` or `self`)
3. Store metadata that the `#[wrapped]` macro can read

**Implementation approach:**

The `#[async_wrap]` attribute doesn't modify the method itself. Instead, it registers the method signature somewhere that `#[wrapped]` can find.

Two approaches:
- **Approach A (simpler):** `#[async_wrap]` is a no-op marker. The `#[wrapped]` macro parses the source file to find marked methods.
- **Approach B (more robust):** `#[async_wrap]` generates a trait or const with method metadata.

**Recommended: Approach A** - simpler to implement, and proc macros can read other files via `include_str!` or by requiring users to use a helper macro.

Actually, the cleanest approach is:

**Approach C: Use a trait**

```rust
use asyncwrap::blocking_impl;

#[blocking_impl]  // This processes the entire impl block
impl BlockingClient {
    #[async_wrap]
    pub fn get_data(&self) -> Result<Data> { ... }

    #[async_wrap]
    pub fn send_command(&self, cmd: Command) -> Result<()> { ... }

    fn internal_helper(&self) { }  // Not marked, not wrapped
}
```

The `#[blocking_impl]` macro:
1. Leaves all methods intact (so blocking API works normally)
2. Generates a hidden trait or const with the signatures of `#[async_wrap]` methods
3. The `#[wrapped]` macro reads this metadata

### Attribute: `#[wrapped(BlockingType)]` or `#[asyncwrap::wrapped(BlockingType)]`

This derive-like attribute on the async struct:

1. Expects the struct to have a field `inner: Arc<BlockingType>`
2. Reads the metadata generated by `#[blocking_impl]`
3. Generates async methods for each marked method

**Generated code pattern:**

For a method like:
```rust
#[async_wrap]
pub fn do_thing(&self, arg1: Foo, arg2: Bar) -> Result<Baz>
```

Generates:
```rust
pub async fn do_thing(&self, arg1: Foo, arg2: Bar) -> Result<Baz> {
    let inner = ::std::sync::Arc::clone(&self.inner);
    ::tokio::task::spawn_blocking(move || inner.do_thing(arg1, arg2))
        .await
        .map_err(|e| /* JoinError handling */)?
}
```

### Error Handling

The `spawn_blocking` returns `Result<T, JoinError>`. We need to handle this.

**Options:**

1. **Require the return type to be `Result<T, E>` where `E: From<JoinError>`**
   - Clean but requires users to impl From<JoinError> for their error type

2. **Panic on JoinError** (task was cancelled/panicked)
   - Simple but not ideal

3. **Wrap in a new error type**
   - Return `Result<T, AsyncWrapError<E>>` where E is the original error

4. **Use a configurable error wrapper**
   - `#[wrapped(BlockingType, error_wrapper = "my_wrap_fn")]`

**Recommended: Option 3 with Option 1 as alternative**

Provide an `AsyncWrapError<E>` enum:
```rust
pub enum AsyncWrapError<E> {
    /// The underlying blocking operation failed
    Inner(E),
    /// The spawned task was cancelled or panicked
    TaskFailed(tokio::task::JoinError),
}
```

But also allow users to opt into unwrapping:
```rust
#[wrapped(BlockingType, unwrap_join_error)]  // panics on JoinError
```

Or:
```rust
#[wrapped(BlockingType, join_error_into)]  // requires E: From<JoinError>
```

### Handling Non-Result Return Types

Some methods might return `T` instead of `Result<T, E>`:

```rust
#[async_wrap]
pub fn get_count(&self) -> usize { ... }
```

Generated:
```rust
pub async fn get_count(&self) -> Result<usize, tokio::task::JoinError> {
    let inner = ::std::sync::Arc::clone(&self.inner);
    ::tokio::task::spawn_blocking(move || inner.get_count()).await
}
```

Or with a wrapper:
```rust
pub async fn get_count(&self) -> usize {
    let inner = ::std::sync::Arc::clone(&self.inner);
    ::tokio::task::spawn_blocking(move || inner.get_count())
        .await
        .expect("blocking task panicked")
}
```

This should be configurable.

### Handling Arguments

Arguments must be `Send + 'static` to cross the spawn_blocking boundary. The macro should:

1. Move all arguments into the closure
2. Potentially warn at compile time if types aren't Send (though rustc will catch this anyway)

### Struct Field Configuration

By default, expect `inner: Arc<BlockingType>`. Allow customization:

```rust
#[wrapped(BlockingClient, field = "client")]
pub struct AsyncClient {
    client: Arc<BlockingClient>,  // Custom field name
}
```

## Project Structure

```
asyncwrap/
├── Cargo.toml              # Workspace root
├── README.md               # User-facing documentation
├── SPEC.md                 # This file
├── asyncwrap/              # Main crate (re-exports)
│   ├── Cargo.toml
│   └── src/
│       └── lib.rs          # Re-exports from asyncwrap-macros, plus AsyncWrapError
├── asyncwrap-macros/       # Proc macro crate
│   ├── Cargo.toml
│   └── src/
│       └── lib.rs          # The actual proc macros
└── tests/                  # Integration tests
    ├── Cargo.toml
    └── src/
        └── lib.rs          # Test cases
```

**Why two crates?**
Proc macros must be in their own crate with `proc-macro = true`. The main `asyncwrap` crate re-exports everything for a nice user experience (`use asyncwrap::async_wrap`).

## Cargo.toml Files

### Root Cargo.toml (workspace)

```toml
[workspace]
members = ["asyncwrap", "asyncwrap-macros", "tests"]
resolver = "2"
```

### asyncwrap/Cargo.toml

```toml
[package]
name = "asyncwrap"
version = "0.1.0"
edition = "2021"
description = "Auto-generate async wrappers for blocking code"
license = "MIT OR Apache-2.0"
repository = "https://github.com/yourusername/asyncwrap"
keywords = ["async", "blocking", "tokio", "macro", "wrapper"]
categories = ["asynchronous", "development-tools::procedural-macro-helpers"]

[dependencies]
asyncwrap-macros = { path = "../asyncwrap-macros", version = "0.1.0" }
tokio = { version = "1", features = ["rt"] }

[dev-dependencies]
tokio = { version = "1", features = ["rt-multi-thread", "macros"] }
```

### asyncwrap-macros/Cargo.toml

```toml
[package]
name = "asyncwrap-macros"
version = "0.1.0"
edition = "2021"
description = "Proc macros for asyncwrap"
license = "MIT OR Apache-2.0"

[lib]
proc-macro = true

[dependencies]
proc-macro2 = "1"
quote = "1"
syn = { version = "2", features = ["full", "parsing", "printing"] }
```

### tests/Cargo.toml

```toml
[package]
name = "asyncwrap-tests"
version = "0.1.0"
edition = "2021"
publish = false

[dependencies]
asyncwrap = { path = "../asyncwrap" }
tokio = { version = "1", features = ["rt-multi-thread", "macros"] }
thiserror = "1"

[dev-dependencies]
```

## Implementation Guide

### Step 1: Basic `#[async_wrap]` Attribute

Start with `#[async_wrap]` as a simple marker that doesn't transform anything:

```rust
// asyncwrap-macros/src/lib.rs
use proc_macro::TokenStream;

#[proc_macro_attribute]
pub fn async_wrap(_attr: TokenStream, item: TokenStream) -> TokenStream {
    // For now, just return the item unchanged
    // The #[blocking_impl] macro will look for this attribute
    item
}
```

### Step 2: `#[blocking_impl]` Macro

This processes the impl block and extracts method signatures:

```rust
#[proc_macro_attribute]
pub fn blocking_impl(_attr: TokenStream, item: TokenStream) -> TokenStream {
    let input = parse_macro_input!(item as syn::ItemImpl);

    // Find all methods with #[async_wrap]
    let wrapped_methods: Vec<_> = input.items.iter()
        .filter_map(|item| {
            if let syn::ImplItem::Fn(method) = item {
                if method.attrs.iter().any(|a| a.path().is_ident("async_wrap")) {
                    return Some(method);
                }
            }
            None
        })
        .collect();

    // Generate a hidden const or trait with method metadata
    // ...

    // Return original impl unchanged (but with #[async_wrap] attrs removed)
    // ...
}
```

### Step 3: `#[wrapped]` Macro

This generates the async impl:

```rust
#[proc_macro_attribute]
pub fn wrapped(attr: TokenStream, item: TokenStream) -> TokenStream {
    let blocking_type = parse_macro_input!(attr as syn::Type);
    let input = parse_macro_input!(item as syn::ItemStruct);

    // Read method metadata (from const/trait generated by #[blocking_impl])
    // Generate async methods
    // Return struct + impl block
}
```

### Alternative Simpler Design (Recommended for v1)

Actually, a simpler design that avoids cross-macro communication:

```rust
// User writes:
asyncwrap::generate! {
    // Paste the blocking impl here or reference it
    impl BlockingClient {
        pub fn get_data(&self) -> Result<Data> { ... }
        pub fn send_command(&self, cmd: Command) -> Result<()> { ... }
    }

    // Generates async wrapper for:
    pub struct AsyncClient {
        inner: Arc<BlockingClient>,
    }
}
```

**Even simpler - just list method signatures:**

```rust
#[asyncwrap::generate(BlockingClient)]
impl AsyncClient {
    // Just declare the signatures, macro generates the bodies
    async fn get_data(&self) -> Result<Data>;
    async fn send_command(&self, cmd: Command) -> Result<()>;
}
```

The macro sees the signatures and generates:
```rust
impl AsyncClient {
    pub async fn get_data(&self) -> Result<Data> {
        let inner = Arc::clone(&self.inner);
        tokio::task::spawn_blocking(move || inner.get_data()).await?
    }
    // ...
}
```

This is less magical but also less error-prone. Users list what they want wrapped explicitly.

**ACTUALLY, THE CLEANEST DESIGN:**

After more thought, here's the cleanest approach that requires minimal user ceremony:

```rust
use asyncwrap::blocking_impl;

#[blocking_impl(AsyncClient)]  // ← Names the async wrapper struct
impl BlockingClient {
    #[async_wrap]
    pub fn get_data(&self) -> Result<Data, Error> {
        // real implementation
    }

    #[async_wrap]
    pub fn send_command(&self, cmd: Command) -> Result<(), Error> {
        // real implementation
    }

    // Not marked = not wrapped
    fn helper(&self) { }
}

// User still needs to define the struct:
pub struct AsyncClient {
    inner: Arc<BlockingClient>,
}
// But the impl is auto-generated!
```

The `#[blocking_impl(AsyncClient)]` macro:
1. Outputs the original impl unchanged
2. ALSO outputs an `impl AsyncClient { ... }` with async wrappers

This way everything is in one place!

## Test Cases

### Test 1: Basic Method Wrapping

```rust
use asyncwrap::blocking_impl;
use std::sync::Arc;

struct BlockingService {
    value: i32,
}

#[blocking_impl(AsyncService)]
impl BlockingService {
    #[async_wrap]
    pub fn get_value(&self) -> i32 {
        self.value
    }

    #[async_wrap]
    pub fn add(&self, n: i32) -> i32 {
        self.value + n
    }
}

pub struct AsyncService {
    inner: Arc<BlockingService>,
}

#[tokio::test]
async fn test_basic_wrapping() {
    let blocking = BlockingService { value: 42 };
    let async_svc = AsyncService { inner: Arc::new(blocking) };

    assert_eq!(async_svc.get_value().await.unwrap(), 42);
    assert_eq!(async_svc.add(8).await.unwrap(), 50);
}
```

### Test 2: Result Return Types

```rust
use thiserror::Error;

#[derive(Error, Debug)]
enum MyError {
    #[error("something failed")]
    Failed,
}

struct BlockingClient;

#[blocking_impl(AsyncClient)]
impl BlockingClient {
    #[async_wrap]
    pub fn might_fail(&self, succeed: bool) -> Result<String, MyError> {
        if succeed {
            Ok("success".to_string())
        } else {
            Err(MyError::Failed)
        }
    }
}

pub struct AsyncClient {
    inner: Arc<BlockingClient>,
}

#[tokio::test]
async fn test_result_types() {
    let client = AsyncClient { inner: Arc::new(BlockingClient) };

    assert!(client.might_fail(true).await.is_ok());
    assert!(client.might_fail(false).await.is_err());
}
```

### Test 3: Multiple Arguments

```rust
struct Calculator;

#[blocking_impl(AsyncCalculator)]
impl Calculator {
    #[async_wrap]
    pub fn compute(&self, a: i32, b: i32, op: char) -> i32 {
        match op {
            '+' => a + b,
            '-' => a - b,
            '*' => a * b,
            '/' => a / b,
            _ => 0,
        }
    }
}

pub struct AsyncCalculator {
    inner: Arc<Calculator>,
}

#[tokio::test]
async fn test_multiple_args() {
    let calc = AsyncCalculator { inner: Arc::new(Calculator) };
    assert_eq!(calc.compute(10, 5, '+').await.unwrap(), 15);
}
```

### Test 4: Private Methods Not Wrapped

```rust
struct Service;

#[blocking_impl(AsyncService)]
impl Service {
    #[async_wrap]
    pub fn public_method(&self) -> i32 { 42 }

    fn private_helper(&self) -> i32 { 0 }  // No #[async_wrap]
}

pub struct AsyncService {
    inner: Arc<Service>,
}

// Verify AsyncService has public_method but NOT private_helper
// (This is a compile-time check - if private_helper existed, this would fail)
#[tokio::test]
async fn test_only_marked_methods() {
    let svc = AsyncService { inner: Arc::new(Service) };
    assert_eq!(svc.public_method().await.unwrap(), 42);
    // svc.private_helper() should not exist and not compile
}
```

### Test 5: Generic Types

```rust
struct GenericService<T> {
    data: T,
}

#[blocking_impl(AsyncGenericService<T>)]
impl<T: Clone + Send + 'static> GenericService<T> {
    #[async_wrap]
    pub fn get_data(&self) -> T {
        self.data.clone()
    }
}

pub struct AsyncGenericService<T> {
    inner: Arc<GenericService<T>>,
}

#[tokio::test]
async fn test_generics() {
    let svc = AsyncGenericService {
        inner: Arc::new(GenericService { data: "hello".to_string() })
    };
    assert_eq!(svc.get_data().await.unwrap(), "hello");
}
```

## Pre-commit Setup

Create `.pre-commit-config.yaml`:

```yaml
repos:
  - repo: local
    hooks:
      - id: cargo-fmt
        name: cargo fmt
        entry: cargo fmt --all --
        language: system
        types: [rust]
        pass_filenames: false

      - id: cargo-clippy
        name: cargo clippy
        entry: cargo clippy --all-targets --all-features -- -D warnings
        language: system
        types: [rust]
        pass_filenames: false

      - id: cargo-test
        name: cargo test
        entry: cargo test --all
        language: system
        types: [rust]
        pass_filenames: false
```

Also create `rustfmt.toml`:

```toml
edition = "2021"
max_width = 100
```

And `clippy.toml` (or add to workspace Cargo.toml):

```toml
# In workspace Cargo.toml
[workspace.lints.clippy]
all = "warn"
pedantic = "warn"
```

## README.md Content

The README should include:

1. **Badges** - crates.io version, docs.rs, CI status
2. **One-liner description**
3. **The Problem** - Show the boilerplate problem
4. **The Solution** - Show how asyncwrap solves it
5. **Installation** - cargo add command
6. **Quick Start** - Minimal working example
7. **How It Works** - Brief explanation
8. **Configuration Options** - All the knobs
9. **Error Handling** - How JoinError is handled
10. **Limitations** - What it can't do
11. **License** - MIT OR Apache-2.0

## Edge Cases to Handle

1. **Methods returning `()`** - Should work, generates `async fn foo(&self) -> Result<(), JoinError>`

2. **Methods with lifetimes in arguments** - Won't work with spawn_blocking (needs 'static). Should emit helpful error.

3. **Methods taking `&mut self`** - Arc<T> only gives &T. Could support Arc<Mutex<T>> pattern but start by rejecting.

4. **Methods taking `self`** - Consumes the value. Probably reject for v1.

5. **Associated functions (no self)** - Could wrap in spawn_blocking without Arc. Support if easy, reject if not.

6. **Async methods on blocking type** - Doesn't make sense, reject.

7. **Attributes on methods** - Preserve doc comments and other attributes on generated methods.

8. **Visibility** - Match the visibility of the original method.

## Success Criteria

The crate is complete when:

1. [ ] All test cases pass
2. [ ] `cargo clippy` passes with no warnings
3. [ ] `cargo fmt --check` passes
4. [ ] `cargo doc` generates clean documentation
5. [ ] README has working examples
6. [ ] Pre-commit hooks are set up and working
7. [ ] CI workflow exists (GitHub Actions)
8. [ ] The crate can be used in the sony-crsdk-rust project successfully

## GitHub Actions CI

Create `.github/workflows/ci.yml`:

```yaml
name: CI

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]

env:
  CARGO_TERM_COLOR: always

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: dtolnay/rust-toolchain@stable
        with:
          components: rustfmt, clippy
      - uses: Swatinem/rust-cache@v2

      - name: Check formatting
        run: cargo fmt --all -- --check

      - name: Clippy
        run: cargo clippy --all-targets --all-features -- -D warnings

      - name: Test
        run: cargo test --all

  docs:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: dtolnay/rust-toolchain@stable
      - uses: Swatinem/rust-cache@v2

      - name: Build docs
        run: cargo doc --no-deps --all-features
        env:
          RUSTDOCFLAGS: -D warnings
```

## Implementation Tips

### Parsing Method Signatures with Syn

```rust
use syn::{ImplItemFn, FnArg, ReturnType, Pat, Type};

fn extract_method_info(method: &ImplItemFn) -> MethodInfo {
    let name = &method.sig.ident;

    // Get arguments (skip self)
    let args: Vec<_> = method.sig.inputs.iter()
        .filter_map(|arg| {
            if let FnArg::Typed(pat_type) = arg {
                let name = if let Pat::Ident(pat_ident) = &*pat_type.pat {
                    pat_ident.ident.clone()
                } else {
                    panic!("Complex patterns not supported");
                };
                let ty = (*pat_type.ty).clone();
                Some((name, ty))
            } else {
                None  // Skip self
            }
        })
        .collect();

    // Get return type
    let return_type = match &method.sig.output {
        ReturnType::Default => None,
        ReturnType::Type(_, ty) => Some((**ty).clone()),
    };

    MethodInfo { name, args, return_type }
}
```

### Generating Async Methods with Quote

```rust
use quote::quote;

fn generate_async_method(method: &MethodInfo, blocking_type: &Type) -> TokenStream2 {
    let name = &method.name;
    let args = &method.args;
    let arg_names: Vec<_> = args.iter().map(|(name, _)| name).collect();
    let arg_types: Vec<_> = args.iter().map(|(_, ty)| ty).collect();

    let return_type = method.return_type.as_ref().map(|ty| {
        quote! { -> ::asyncwrap::Result<#ty> }
    }).unwrap_or_else(|| {
        quote! { -> ::asyncwrap::Result<()> }
    });

    quote! {
        pub async fn #name(&self, #(#arg_names: #arg_types),*) #return_type {
            let inner = ::std::sync::Arc::clone(&self.inner);
            ::tokio::task::spawn_blocking(move || {
                inner.#name(#(#arg_names),*)
            })
            .await
            .map_err(::asyncwrap::AsyncWrapError::from)?
        }
    }
}
```

## Questions to Resolve During Implementation

1. **Naming**: Is `asyncwrap` the best name? Alternatives: `async-blocking`, `spawn-wrap`, `blocking-async`

2. **Error handling default**: Should non-Result methods panic on JoinError or return Result?

3. **Field name**: Hardcode `inner` or make configurable?

4. **Visibility**: Should generated methods always be `pub` or match source?

5. **Documentation**: Copy doc comments from source methods?

## Final Notes

This is a genuinely useful crate that fills a gap in the Rust async ecosystem. Build it well, document it thoroughly, and it could become a popular utility crate.

Start simple:
1. Get basic method wrapping working
2. Add Result handling
3. Add configuration options
4. Polish documentation and error messages

Good luck! Feel free to deviate from this spec if you find better approaches during implementation.
